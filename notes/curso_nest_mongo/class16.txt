AGREGANDO UN FILTRO PARA RANGO DE PRECIOS

Los endpoints del tipo GET, ademÃ¡s de paginar la informaciÃ³n, pueden tener otro tipo de filtros mÃ¡s especÃ­ficos para una regla de negocio. MongoDB permite crear cualquier tipo de filtro que necesite tu servicio.

Filtro de rango numÃ©rico
Crear un filtro entre dos nÃºmeros X e Y que podrÃ­an ser aÃ±os o precios de productos es un caso de uso bastante habitual en la consulta de datos.

Paso 1: tipado de datos
Comienza creando el DTO para que el constructor reciba estos datos.

// products/products.dto.ts
import { ValidateIf } from 'class-validator';

export class FilterProductsDto {

  @IsOptional()
  @Min(0)
  minPrice: number;

  @ValidateIf((params) => params.minPrice)
  @IsPositive()
  maxPrice: number;
}
Utilizamos el decorador @ValidateIf() para validar el precio mÃ¡ximo solo si existe el mÃ­nimo y tambiÃ©n es vÃ¡lido.

Paso 2: preparar el servicio para el filtro
Preparar el servicio para recibir estos nuevos datos y filtrar por rango mÃ­nimo y mÃ¡ximos un determinado campo del esquema.

// products/products.service.ts
import { Model, FilterQuery } from 'mongoose';

@Injectable()
export class ProductsService {

  findAll(params?: FilterProductsDto) {
    if (params) {
      const filters: FilterQuery<Product> = {};
      const { minPrice, maxPrice } = params;
      if (minPrice && maxPrice) {
        filters.price = { $gte: minPrice, $lte: maxPrice };
      }
      return this.productModel.find(filters).exec();
    }
    return this.productModel.find().exec();
  }
}
Para crear el filtro de rangos mÃ¡ximos y mÃ­nimos, MongoDB utiliza operadores de comparaciones especiales:

$gte equivalente a >=
$lte equivalente a <=
De esta manera, el servicio estÃ¡ preparado para realizar un filtro numÃ©rico si el usuario ingresa el rango. Recuerda que este tipo de filtros suelen ser opcionales, el endpoint debe seguir funcionando correctamente en el caso de que no se ingrese un filtro.

ContribuciÃ³n creada por: Kevin Fiorentino (Platzi Contributor).

CÃ³digo de ejemplo para filtro de rango de precios
// src/products/dtos/products.dtos.ts

import {
  ...,
  ValidateIf // ðŸ‘ˆ new decorator
} from 'class-validator';

export class FilterProductsDto {
  ...
  @IsOptional()
  @Min(0)
  minPrice: number; // ðŸ‘ˆ new field

  @ValidateIf((params) => params.minPrice)
  @IsPositive()
  maxPrice: number;  // ðŸ‘ˆ new field
}
// src/products/services/products.service.ts
import { Model, FilterQuery } from 'mongoose';

@Injectable()
export class ProductsService {
  ...

  findAll(params?: FilterProductsDto) {
    if (params) {
      const filters: FilterQuery<Product> = {}; // ðŸ‘ˆ create filters
      const { limit, offset } = params;
      const { minPrice, maxPrice } = params; // ðŸ‘ˆ
      if (minPrice && maxPrice) {
        filters.price = { $gte: minPrice, $lte: maxPrice };
      }
      return this.productModel.find(filters).skip(offset).limit(limit).exec();
    }
    return this.productModel.find().exec();
  }
  ..
}
