AGREGANDO PAGINACI√ìN

Una base de datos puede tener miles y miles de registros, los cuales conviene consultar de forma gradual y en partes para que sea m√°s ameno para el usuario que consume la informaci√≥n.

C√≥mo es la paginaci√≥n en MongoDB
Las consultas que realices en MongoDB permiten separar los resultados en partes iguales y desarrollar en el front-end la t√≠pica l√≥gica de paginaci√≥n de resultados.

Paso 1: tipado de datos
Comienza creando un DTO para el tipado de los datos que construir√°n la paginaci√≥n.

// products/products.dto.ts

import { IsOptional, Min } from 'class-validator';
export class FilterProductsDto {

  @IsOptional()
  @IsPositive()
  limit: number;        // Cantidad de registros por p√°gina

  @IsOptional()
  @Min(0)
  offset: number;      // N√∫mero de registros a ignorar
}
Paso 2: aplicar ‚Äúlimit‚Äù y ‚Äúoffset‚Äù en el servicio
El servicio de lectura de los registros recibe los par√°metros para crear el paginador y utilizarlos en la consulta.

// products/products.service.ts
import { FilterProductsDto } from './products.dtos';

@Injectable()
export class ProductsService {

  findAll(params?: FilterProductsDto) {
    if (params) {
      const { limit, offset } = params;
      return this.productModel.find().skip(offset).limit(limit).exec();
    }
    return this.productModel.find().exec();
  }
}
Paso 3: endpoint paginador de registros
El controlador ser√° el encargado de recibir estos datos y pas√°rselos al servicio para devolver los datos paginados.

// products/products.controller.ts
import { FilterProductsDto } from '../dtos/products.dtos';

@Controller('products')
export class ProductsController {

  @Get()
  getProducts(@Query() params: FilterProductsDto) {
    return this.productsService.findAll(params);
  }
}
Los par√°metros que construyen un paginador suelen recibirse por medio de Query Params y estos deben ser opcionales. El backend tiene que contemplar valores por defecto en el caso de que el front-end no env√≠e nada y el endpoint debe continuar funcionando correctamente.

Paso 4: configuraci√≥n de Query Params
Por defecto, todos los Query Params son del tipo String. NestJS nos ayuda a convertirlos a n√∫meros enteros con la siguiente configuraci√≥n en el archivo main.ts.

// src/main.ts
new ValidationPipe({
  transformOptions: {
    enableImplicitConversion: true,    // Convertir Query Params a n√∫meros entero
  }
})
De esta manera, tu endpoint del tipo GET se encuentra listo para permitirle al front-end crear un paginador y facilitar la lectura de resultados a los usuarios.

Contribuci√≥n creada por: Kevin Fiorentino.

C√≥digo de ejemplo para agregar paginaci√≥n
// src/products/dtos/products.dtos.ts

import {
 ...
  IsOptional, // üëà new decorator
  Min,  // üëà new decorator
} from 'class-validator';

...

export class FilterProductsDto { // üëà new DTO
  @IsOptional()
  @IsPositive()
  limit: number;

  @IsOptional()
  @Min(0)
  offset: number;
}
// src/products/services/products.service.ts

import {
  CreateProductDto,
  UpdateProductDto,
  FilterProductsDto,  // üëà import DTO
} from './../dtos/products.dtos';

@Injectable()
export class ProductsService {

  findAll(params?: FilterProductsDto) { // üëà
    if (params) {
      const { limit, offset } = params;
      return this.productModel.find().skip(offset).limit(limit).exec();  // üëà
    }
    return this.productModel.find().exec();
  }

}
// src/products/controllers/products.controller.ts

import { ..., FilterProductsDto } from '../dtos/products.dtos'; // üëà import DTO

@Controller('products')
export class ProductsController {
  ...

  @Get()
  @ApiOperation({ summary: 'List of products' })
  getProducts(@Query() params: FilterProductsDto) { // üëà
    return this.productsService.findAll(params);
  }

  ...

}
