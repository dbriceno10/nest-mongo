GLOBAL MODULE

Al desarrollar una aplicaci贸n con NestJS, existen necesidades de importar m贸dulos cruzados o de importar un mismo servicio en varios m贸dulos. Lo anterior, hace que la cantidad de imports en cada m贸dulo crezca y se vuelva complicado de escalar.

C贸mo usar el m贸dulo global
NestJS otorga la posibilidad de crear m贸dulos globales que se importar谩n autom谩ticamente en todos los otros m贸dulos de la aplicaci贸n, sin necesidad de importarlos expl铆citamente.

import { Module, Global } from '@nestjs/common';

@Global()
@Module({
  // ...
})
export class MyCustomModule {}
Todos los servicios que importes en este m贸dulo, estar谩n disponibles para su utilizaci贸n en cualquier otro m贸dulo.

Es importante no abusar de esta caracter铆stica y no tener m谩s de un m贸dulo global para controlar las importaciones. Pueden ocurrir errores de dependencias circulares que suceden cuando el M贸dulo A importa al M贸dulo B y este a su vez importa al M贸dulo A. El decorador @Global() te ayudar谩 a resolver estos problemas.

Cuadro de c贸digo para uso de global module
// src/database/database.module.ts

import { Module, Global } from '@nestjs/common';

const API_KEY = '12345634';
const API_KEY_PROD = 'PROD1212121SA';

@Global()
@Module({
  providers: [
    {
      provide: 'API_KEY',
      useValue: process.env.NODE_ENV === 'prod' ? API_KEY_PROD : API_KEY,
    },
  ],
  exports: ['API_KEY'],
})
export class DatabaseModule {}
// src/app.module.ts
...
import { DatabaseModule } from './database/database.module';

@Module({
  imports: [
    HttpModule,
    UsersModule,
    ProductsModule,
    DatabaseModule //  Use DatabaseModule like global Module
   ],
  ...
})
export class AppModule {}
// src/users/services/users.service.ts

import { Injectable, NotFoundException, Inject } from '@nestjs/common';
..

@Injectable()
export class UsersService {
  constructor(
    private productsService: ProductsService,
    @Inject('API_KEY') private apiKey: string, //  Inject API_KEY
  ) {}

}
Contribuci贸n creada por: Kevin Fiorentino.
