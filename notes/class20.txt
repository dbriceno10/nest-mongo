RELACIONES UNO A MUCHOS EMBEBIDAS

Un tipo de relaci√≥n entre documentos en MongoDB es el ‚Äúuno a muchos‚Äù de forma embebida. As√≠ como puedes guardar un objeto dentro de otro, puedes guardar un array de objetos dentro de un objeto principal.

Array de documentos dentro de un objeto
Para lograr este tipo de relaci√≥n, hazlo de la siguiente manera:

Paso 1: preparaci√≥n del esquema
Agrega este nuevo tipo de relaci√≥n en el esquema de tu colecci√≥n de Mongo.

// users/customer.entity.ts
import { Document, Types } from 'mongoose';

export class Customer extends Document {

  @Prop({
    type: [{
      name: { type: String },
      color: { type: String }
    }],
  })
  skills: Types.Array<Record<string, any>>;
}
El decorador @Prop() recibe una propiedad type que es un array con un ejemplo de la estructura de datos que tendr√° cada sub documento.

Paso 2: preparaci√≥n del DTO
Ahora solo prepara el DTO para recibir este nuevo campo:

// users/customer.dto.ts
import { IsNotEmpty, IsArray } from 'class-validator';

export class Skills {  // Sub clase para tipar los datos

  @IsNotEmpty()
  name: string;

  @IsNotEmpty()
  color: string;
}

export class CreateCustomerDto {

  @ValidateNested()
  @Type(() => Skills)
  readonly skills: Skills[];
}
Creamos una clase auxiliar denominada Skills que utilizaremos para tipar los datos y el decorador @ValidateNested() que har√° la validaci√≥n de forma recursiva, objeto por objeto dentro del array.

De esta manera, ya puedes guardar todo un array de objetos, dentro de un documento principal. Ten en cuenta que cada documento de MongoDB tiene un m√°ximo de tama√±o de 16MB. Considera esto a la hora de dise√±ar tu base de datos.

Contribuci√≥n creada por Kevin Fiorentino (Platzi Contributor), con aportes de Guillermo Rodas G√≥mez.

C√≥digo de ejemplo para relaciones uno a muchos embebidas
// src/users/entities/customer.entity.ts
import { Document, Types } from 'mongoose';

export class Customer extends Document {
  ...
  @Prop({
    type: [{ name: { type: String }, color: { type: String } }],
  })
  skills: Types.Array<Record<string, any>>; // üëà field
}
// src/users/dtos/customer.dto.ts
import {
  IsString,
  IsNotEmpty,
  IsPhoneNumber,
  IsArray, // üëà new decorator
  ValidateNested,  // üëà new decorator
} from 'class-validator';
import { PartialType } from '@nestjs/swagger';

export class CreateCustomerDto {
   ...
  @IsArray()
  @IsNotEmpty()
  readonly skills: any; // üëà new field
}




SOLUCION PARA TIPAR EL Array

Cree una clase Skills que contengan los atributos a validar
export class Skills {
  @IsNotEmpty()
  name: string;

  @IsNotEmpty()
  color: string;
}
Luego hice que la variable skills sea del tipo array de Skills y le coloqu√© el decorador @ValidateNested(), y el decorar @Type especificando el tipo de array:
 @ValidateNested()
  @Type(() => Skills)
  readonly skills: Skills[];
Obteniendo as√≠ el archivo customer.dto.ts

import {
  IsString,
  IsNotEmpty,
  IsPhoneNumber,
  ValidateNested,
} from 'class-validator';
import { PartialType } from '@nestjs/swagger';
import { Type } from 'class-transformer';

export class Skills {
  @IsNotEmpty()
  name: string;

  @IsNotEmpty()
  color: string;
}

export class CreateCustomerDto {
  @IsString()
  @IsNotEmpty()
  readonly name: string;

  @IsString()
  @IsNotEmpty()
  readonly lastName: string;

  @IsPhoneNumber()
  @IsNotEmpty()
  readonly phone: string;

  @ValidateNested()
  @Type(() => Skills)
  readonly skills: Skills[];
}

export class UpdateCustomerDto extends PartialType(CreateCustomerDto) {}
